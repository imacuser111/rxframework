// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: QPPProto.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///錯誤相關編號
enum QPPProto_ECode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case ok // = 0

  ///目前改用在非設定的錯誤,前端直接秀server給的msg
  case exception // = 1
  case account // = 2

  ///about通行證的錯誤 //前端處置:對俊谷refresh token
  case token // = 3

  ///about重要程序正在進行中,無法執行要求 //ex.websocket登出中,無法登入 //前端處置:再試一次
  case playing // = 4

  ///about轉換失敗 //目前無此錯誤
  case transfer // = 5

  ///about參數錯誤 //除非有BUG,不應該有參數錯誤 //Alert:參數錯誤
  case argument // = 6

  ///about資料庫錯誤          //Alert:DB發生非預期的錯誤，請稍候再試。 //前端處置:畫面停留不動
  case dbError // = 7

  ///about RedisCache錯誤  //Alert:Cache發生非預期的錯誤，請稍候再試。 //前端處置:畫面停留不動
  case cacheError // = 8

  ///about memory錯誤     //Alert:Memory發生非預期的錯誤，請稍候再試。 //前端處置:畫面停留不動
  case memoryError // = 9

  ///about帳號的錯誤 //主動封包 //Alert:未建立連線 //前端處置:重新建立Websocket連線
  case notLoginWs // = 10

  ///about帳號的錯誤    //Alert:未登入QPP帳號 //前端處置:彈出QPP登入
  case notLoginQpp // = 11

  ///TOKEN_LOGIN時,Token失效,重走PreLogin
  case tokenInvalid // = 12
  case UNRECOGNIZED(Int)

  init() {
    self = .ok
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ok
    case 1: self = .exception
    case 2: self = .account
    case 3: self = .token
    case 4: self = .playing
    case 5: self = .transfer
    case 6: self = .argument
    case 7: self = .dbError
    case 8: self = .cacheError
    case 9: self = .memoryError
    case 10: self = .notLoginWs
    case 11: self = .notLoginQpp
    case 12: self = .tokenInvalid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ok: return 0
    case .exception: return 1
    case .account: return 2
    case .token: return 3
    case .playing: return 4
    case .transfer: return 5
    case .argument: return 6
    case .dbError: return 7
    case .cacheError: return 8
    case .memoryError: return 9
    case .notLoginWs: return 10
    case .notLoginQpp: return 11
    case .tokenInvalid: return 12
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension QPPProto_ECode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [QPPProto_ECode] = [
    .ok,
    .exception,
    .account,
    .token,
    .playing,
    .transfer,
    .argument,
    .dbError,
    .cacheError,
    .memoryError,
    .notLoginWs,
    .notLoginQpp,
    .tokenInvalid,
  ]
}

#endif  // swift(>=4.2)

enum QPPProto_EAccountType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case guest // = 0
  case phone // = 1

  ///Account_password
  case acctPw // = 2

  ///拉掉APP後再開啟,用既有的Toekn登入System
  case tokenLogin // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .guest
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .guest
    case 1: self = .phone
    case 2: self = .acctPw
    case 3: self = .tokenLogin
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .guest: return 0
    case .phone: return 1
    case .acctPw: return 2
    case .tokenLogin: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension QPPProto_EAccountType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [QPPProto_EAccountType] = [
    .guest,
    .phone,
    .acctPw,
    .tokenLogin,
  ]
}

#endif  // swift(>=4.2)

enum QPPProto_EDeviceKind: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case deviceOther // = 0
  case android // = 1
  case ios // = 2
  case web // = 3
  case mweb // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .deviceOther
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .deviceOther
    case 1: self = .android
    case 2: self = .ios
    case 3: self = .web
    case 4: self = .mweb
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .deviceOther: return 0
    case .android: return 1
    case .ios: return 2
    case .web: return 3
    case .mweb: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension QPPProto_EDeviceKind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [QPPProto_EDeviceKind] = [
    .deviceOther,
    .android,
    .ios,
    .web,
    .mweb,
  ]
}

#endif  // swift(>=4.2)

///登入系統後缺資料
enum QPPProto_ENeedData: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case noNeed // = 0

  ///創角
  case create // = 1

  ///uni-name
  case uname // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .noNeed
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noNeed
    case 1: self = .create
    case 2: self = .uname
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noNeed: return 0
    case .create: return 1
    case .uname: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension QPPProto_ENeedData: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [QPPProto_ENeedData] = [
    .noNeed,
    .create,
    .uname,
  ]
}

#endif  // swift(>=4.2)

///伺服器功能種類,FuncServ2SysServ用
enum QPPProto_EFunServType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case undefine // = 0
  case qpp // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .undefine
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefine
    case 1: self = .qpp
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefine: return 0
    case .qpp: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension QPPProto_EFunServType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [QPPProto_EFunServType] = [
    .undefine,
    .qpp,
  ]
}

#endif  // swift(>=4.2)

enum QPPProto_ETarget: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case noTarget // = 0

  ///影片
  case article // = 1

  ///留言
  case comment // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .noTarget
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noTarget
    case 1: self = .article
    case 2: self = .comment
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noTarget: return 0
    case .article: return 1
    case .comment: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension QPPProto_ETarget: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [QPPProto_ETarget] = [
    .noTarget,
    .article,
    .comment,
  ]
}

#endif  // swift(>=4.2)

///未刪除:0 1:已刪 2:被官方刪
enum QPPProto_EDelete: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case noDel // = 0
  case self_ // = 1
  case official // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .noDel
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noDel
    case 1: self = .self_
    case 2: self = .official
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noDel: return 0
    case .self_: return 1
    case .official: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension QPPProto_EDelete: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [QPPProto_EDelete] = [
    .noDel,
    .self_,
    .official,
  ]
}

#endif  // swift(>=4.2)

///發生錯誤，終止遊戲
struct QPPProto_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: QPPProto_ECode = .ok

  var msg: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///server踢人，終止遊戲
struct QPPProto_Kick {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: QPPProto_ECode = .ok

  var msg: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///使用者系統設定
struct QPPProto_SysSetting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///追踨推播
  var trackPush: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct QPPProto_Article {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var articleID: String = String()

  var title: String = String()

  var authorMobilKey: String = String()

  var url: String = String()

  ///TS:timestamp
  var publishTs: Int64 = 0

  ///直播中
  var live: Bool = false

  ///大類別,應該用不到
  var categoryNo: Int32 = 0

  var commentCount: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///留言
struct QPPProto_Comment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///UTC唯一key
  var commentID: String = String()

  var authorMobilKey: String = String()

  var articleID: String = String()

  var commentFloor: Int32 = 0

  ///留言時間
  var commentTs: Int64 = 0

  ///HTML格式
  var commentContent: String = String()

  var delete: QPPProto_EDelete = .noDel

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct QPPProto_Profile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mobilKey: String = String()

  ///QPP名字
  var name: String = String()

  ///頭貼時戳
  var imgTs: Int64 = 0

  ///暱稱時戳
  var infoTs: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct QPPProto_AD {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String = String()

  ///強迫看完
  var force: Bool = false

  ///幾時後可跳離廣告(ms)
  var skip: Int64 = 0

  ///播放長度(ms)
  var totalTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///Client to Server -------------interval----------------
struct QPPProto_Login {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///data
  var msg: QPPProto_Login.OneOf_Msg? = nil

  var pls: QPPProto_Login.PreLoginSys {
    get {
      if case .pls(let v)? = msg {return v}
      return QPPProto_Login.PreLoginSys()
    }
    set {msg = .pls(newValue)}
  }

  var ls: QPPProto_Login.LoginSys {
    get {
      if case .ls(let v)? = msg {return v}
      return QPPProto_Login.LoginSys()
    }
    set {msg = .ls(newValue)}
  }

  var lf: QPPProto_Login.LoginFServ {
    get {
      if case .lf(let v)? = msg {return v}
      return QPPProto_Login.LoginFServ()
    }
    set {msg = .lf(newValue)}
  }

  var recnnt: QPPProto_Login.Reconnect {
    get {
      if case .recnnt(let v)? = msg {return v}
      return QPPProto_Login.Reconnect()
    }
    set {msg = .recnnt(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///data
  enum OneOf_Msg: Equatable {
    case pls(QPPProto_Login.PreLoginSys)
    case ls(QPPProto_Login.LoginSys)
    case lf(QPPProto_Login.LoginFServ)
    case recnnt(QPPProto_Login.Reconnect)

  #if !swift(>=4.1)
    static func ==(lhs: QPPProto_Login.OneOf_Msg, rhs: QPPProto_Login.OneOf_Msg) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pls, .pls): return {
        guard case .pls(let l) = lhs, case .pls(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ls, .ls): return {
        guard case .ls(let l) = lhs, case .ls(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lf, .lf): return {
        guard case .lf(let l) = lhs, case .lf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.recnnt, .recnnt): return {
        guard case .recnnt(let l) = lhs, case .recnnt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  ///inner types-------------interval----------------
  struct PreLoginSys {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///phone account: ex.886-910123456
    var acct: String = String()

    var type: QPPProto_EAccountType = .guest

    var dkind: QPPProto_EDeviceKind = .deviceOther

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///帳密/第三方/Tk+reTk/門號+密碼的直接登入,取得Token及真人
  struct LoginSys {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///token //取得通行證後,下次重開App走token/refreshToken登入
    var acct: String = String()

    ///refreshToken
    var pw: String = String()

    var type: QPPProto_EAccountType = .guest

    var dkind: QPPProto_EDeviceKind = .deviceOther

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///Token登入功能服,取得功能人
  struct LoginFServ {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///Login Server給的通行證
    var token: String = String()

    var dkind: QPPProto_EDeviceKind = .deviceOther

    ///系統分流識別ID    //#Jas 20211229 //! 加分流識別ID
    var sservID: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///只要有Token,都能斷線重連
  struct Reconnect {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var token: String = String()

    ///上一次接收到的封包時戳
    var recvTs: Int64 = 0

    var dkind: QPPProto_EDeviceKind = .deviceOther

    ///系統分流識別ID    //#Jas 20211229 //! 加分流識別ID
    var sservID: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct QPPProto_ClientPack {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///UTC timestamp
  var sts: Int64 = 0

  ///已讀時戳(Server的最後一包封包的傳送時戳)
  var rts: Int64 = 0

  ///client的自定義編號,可直接用sts,server會照著回
  var no: Int64 = 0

  ///data
  var msg: QPPProto_ClientPack.OneOf_Msg? = nil

  ///系統底層溝通----------------------------------------------
  var confirmRes: QPPProto_ClientPack.ReadConfirmResult {
    get {
      if case .confirmRes(let v)? = msg {return v}
      return QPPProto_ClientPack.ReadConfirmResult()
    }
    set {msg = .confirmRes(newValue)}
  }

  var changeSys: QPPProto_ClientPack.ChangeSystem {
    get {
      if case .changeSys(let v)? = msg {return v}
      return QPPProto_ClientPack.ChangeSystem()
    }
    set {msg = .changeSys(newValue)}
  }

  ///系統應用層溝通------------------------------------------------
  var quit: QPPProto_ClientPack.Quit {
    get {
      if case .quit(let v)? = msg {return v}
      return QPPProto_ClientPack.Quit()
    }
    set {msg = .quit(newValue)}
  }

  ///重新要求發送驗證碼(SMS/eMail)
  var againVerifyCode: QPPProto_ClientPack.AgainVerifyCode {
    get {
      if case .againVerifyCode(let v)? = msg {return v}
      return QPPProto_ClientPack.AgainVerifyCode()
    }
    set {msg = .againVerifyCode(newValue)}
  }

  var verifyPreLogin: QPPProto_ClientPack.VerifyPreLogin {
    get {
      if case .verifyPreLogin(let v)? = msg {return v}
      return QPPProto_ClientPack.VerifyPreLogin()
    }
    set {msg = .verifyPreLogin(newValue)}
  }

  ///功能應用層------------------------------------------------
  var createAcct: QPPProto_ClientPack.CreateAccount {
    get {
      if case .createAcct(let v)? = msg {return v}
      return QPPProto_ClientPack.CreateAccount()
    }
    set {msg = .createAcct(newValue)}
  }

  var createUname: QPPProto_ClientPack.CreateUName {
    get {
      if case .createUname(let v)? = msg {return v}
      return QPPProto_ClientPack.CreateUName()
    }
    set {msg = .createUname(newValue)}
  }

  var sysSetting: QPPProto_SysSetting {
    get {
      if case .sysSetting(let v)? = msg {return v}
      return QPPProto_SysSetting()
    }
    set {msg = .sysSetting(newValue)}
  }

  var postComment: QPPProto_ClientPack.PostComment {
    get {
      if case .postComment(let v)? = msg {return v}
      return QPPProto_ClientPack.PostComment()
    }
    set {msg = .postComment(newValue)}
  }

  var modifyComment: QPPProto_ClientPack.ModifyComment {
    get {
      if case .modifyComment(let v)? = msg {return v}
      return QPPProto_ClientPack.ModifyComment()
    }
    set {msg = .modifyComment(newValue)}
  }

  var deleteComment: QPPProto_ClientPack.DeleteComment {
    get {
      if case .deleteComment(let v)? = msg {return v}
      return QPPProto_ClientPack.DeleteComment()
    }
    set {msg = .deleteComment(newValue)}
  }

  var commentList: QPPProto_ClientPack.CommentList {
    get {
      if case .commentList(let v)? = msg {return v}
      return QPPProto_ClientPack.CommentList()
    }
    set {msg = .commentList(newValue)}
  }

  ///檢舉
  var postReport: QPPProto_ClientPack.PostReport {
    get {
      if case .postReport(let v)? = msg {return v}
      return QPPProto_ClientPack.PostReport()
    }
    set {msg = .postReport(newValue)}
  }

  ///要個人資訊(多筆)
  var profiles: QPPProto_ClientPack.Profiles {
    get {
      if case .profiles(let v)? = msg {return v}
      return QPPProto_ClientPack.Profiles()
    }
    set {msg = .profiles(newValue)}
  }

  ///問一個期間的QPP個人資訊更新
  var refreshProfile: QPPProto_ClientPack.RefreshProfile {
    get {
      if case .refreshProfile(let v)? = msg {return v}
      return QPPProto_ClientPack.RefreshProfile()
    }
    set {msg = .refreshProfile(newValue)}
  }

  var liveInit: QPPProto_ClientPack.LiveInit {
    get {
      if case .liveInit(let v)? = msg {return v}
      return QPPProto_ClientPack.LiveInit()
    }
    set {msg = .liveInit(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///data
  enum OneOf_Msg: Equatable {
    ///系統底層溝通----------------------------------------------
    case confirmRes(QPPProto_ClientPack.ReadConfirmResult)
    case changeSys(QPPProto_ClientPack.ChangeSystem)
    ///系統應用層溝通------------------------------------------------
    case quit(QPPProto_ClientPack.Quit)
    ///重新要求發送驗證碼(SMS/eMail)
    case againVerifyCode(QPPProto_ClientPack.AgainVerifyCode)
    case verifyPreLogin(QPPProto_ClientPack.VerifyPreLogin)
    ///功能應用層------------------------------------------------
    case createAcct(QPPProto_ClientPack.CreateAccount)
    case createUname(QPPProto_ClientPack.CreateUName)
    case sysSetting(QPPProto_SysSetting)
    case postComment(QPPProto_ClientPack.PostComment)
    case modifyComment(QPPProto_ClientPack.ModifyComment)
    case deleteComment(QPPProto_ClientPack.DeleteComment)
    case commentList(QPPProto_ClientPack.CommentList)
    ///檢舉
    case postReport(QPPProto_ClientPack.PostReport)
    ///要個人資訊(多筆)
    case profiles(QPPProto_ClientPack.Profiles)
    ///問一個期間的QPP個人資訊更新
    case refreshProfile(QPPProto_ClientPack.RefreshProfile)
    case liveInit(QPPProto_ClientPack.LiveInit)

  #if !swift(>=4.1)
    static func ==(lhs: QPPProto_ClientPack.OneOf_Msg, rhs: QPPProto_ClientPack.OneOf_Msg) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.confirmRes, .confirmRes): return {
        guard case .confirmRes(let l) = lhs, case .confirmRes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.changeSys, .changeSys): return {
        guard case .changeSys(let l) = lhs, case .changeSys(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.quit, .quit): return {
        guard case .quit(let l) = lhs, case .quit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.againVerifyCode, .againVerifyCode): return {
        guard case .againVerifyCode(let l) = lhs, case .againVerifyCode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.verifyPreLogin, .verifyPreLogin): return {
        guard case .verifyPreLogin(let l) = lhs, case .verifyPreLogin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createAcct, .createAcct): return {
        guard case .createAcct(let l) = lhs, case .createAcct(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createUname, .createUname): return {
        guard case .createUname(let l) = lhs, case .createUname(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sysSetting, .sysSetting): return {
        guard case .sysSetting(let l) = lhs, case .sysSetting(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postComment, .postComment): return {
        guard case .postComment(let l) = lhs, case .postComment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.modifyComment, .modifyComment): return {
        guard case .modifyComment(let l) = lhs, case .modifyComment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteComment, .deleteComment): return {
        guard case .deleteComment(let l) = lhs, case .deleteComment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.commentList, .commentList): return {
        guard case .commentList(let l) = lhs, case .commentList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postReport, .postReport): return {
        guard case .postReport(let l) = lhs, case .postReport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.profiles, .profiles): return {
        guard case .profiles(let l) = lhs, case .profiles(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.refreshProfile, .refreshProfile): return {
        guard case .refreshProfile(let l) = lhs, case .refreshProfile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.liveInit, .liveInit): return {
        guard case .liveInit(let l) = lhs, case .liveInit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  ///inner types-------------interval----------------
  struct ReadConfirmResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ChangeSystem {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///系統分流識別ID    //#Jas 20211229 //! 加分流識別ID
    var sservID: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Quit {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct AgainVerifyCode {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct VerifyPreLogin {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///驗證碼 //測試服送123456
    var code: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CreateAccount {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uname: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CreateUName {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uname: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CommentList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var articleID: String = String()

    ///下一頁/下一筆/下一時戳 //首次下:0
    var nextSp: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PostComment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var articleID: String = String()

    ///HTML格式 //"<p>A1234567890B1234567890留言文字，長度有限制，要長一點點</p>"
    var content: String = String()

    var imgCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ModifyComment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var commentID: String = String()

    var content: String = String()

    var imgCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct DeleteComment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var commentID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Profiles {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var aryMkey: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RefreshProfile {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///上一次訪問後的時戳
    var lastTs: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PostReport {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var target: QPPProto_ETarget = .noTarget

    var id: String = String()

    var reason: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct LiveInit {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var startTime: Int64 = 0

    var watchs: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

///Any_Server login_response to Client -------------interval----------------
struct QPPProto_LoginResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///data
  var msg: QPPProto_LoginResult.OneOf_Msg? = nil

  var error: QPPProto_Error {
    get {
      if case .error(let v)? = msg {return v}
      return QPPProto_Error()
    }
    set {msg = .error(newValue)}
  }

  var plssucc: QPPProto_LoginResult.PLSSuccess {
    get {
      if case .plssucc(let v)? = msg {return v}
      return QPPProto_LoginResult.PLSSuccess()
    }
    set {msg = .plssucc(newValue)}
  }

  var ssucc: QPPProto_LoginResult.SSuccess {
    get {
      if case .ssucc(let v)? = msg {return v}
      return QPPProto_LoginResult.SSuccess()
    }
    set {msg = .ssucc(newValue)}
  }

  var fsucc: QPPProto_LoginResult.FSuccess {
    get {
      if case .fsucc(let v)? = msg {return v}
      return QPPProto_LoginResult.FSuccess()
    }
    set {msg = .fsucc(newValue)}
  }

  var recnntSucc: QPPProto_LoginResult.ReconnectSucc {
    get {
      if case .recnntSucc(let v)? = msg {return v}
      return QPPProto_LoginResult.ReconnectSucc()
    }
    set {msg = .recnntSucc(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///data
  enum OneOf_Msg: Equatable {
    case error(QPPProto_Error)
    case plssucc(QPPProto_LoginResult.PLSSuccess)
    case ssucc(QPPProto_LoginResult.SSuccess)
    case fsucc(QPPProto_LoginResult.FSuccess)
    case recnntSucc(QPPProto_LoginResult.ReconnectSucc)

  #if !swift(>=4.1)
    static func ==(lhs: QPPProto_LoginResult.OneOf_Msg, rhs: QPPProto_LoginResult.OneOf_Msg) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.plssucc, .plssucc): return {
        guard case .plssucc(let l) = lhs, case .plssucc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ssucc, .ssucc): return {
        guard case .ssucc(let l) = lhs, case .ssucc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fsucc, .fsucc): return {
        guard case .fsucc(let l) = lhs, case .fsucc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.recnntSucc, .recnntSucc): return {
        guard case .recnntSucc(let l) = lhs, case .recnntSucc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  ///inner types-------------interval----------------
  struct PLSSuccess {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///系統分流識別ID
    var sservID: Int32 = 0

    ///System server給的通行碼
    var token: String = String()

    var refreshToken: String = String()

    ///送存活包的間隔秒數,所有Server都用這個值
    var aliveSec: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///login System success
  struct SSuccess {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///系統分流識別ID
    var sservID: Int32 = 0

    ///System server給的通行碼
    var token: String = String()

    var refreshToken: String = String()

    ///送存活包的間隔秒數,所有Server都用這個值
    var aliveSec: Int32 = 0

    ///玩家資料的部份
    var nick: String = String()

    var sysSetting: QPPProto_SysSetting {
      get {return _sysSetting ?? QPPProto_SysSetting()}
      set {_sysSetting = newValue}
    }
    /// Returns true if `sysSetting` has been explicitly set.
    var hasSysSetting: Bool {return self._sysSetting != nil}
    /// Clears the value of `sysSetting`. Subsequent reads from it will return its default value.
    mutating func clearSysSetting() {self._sysSetting = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sysSetting: QPPProto_SysSetting? = nil
  }

  ///login ForumServer success
  struct FSuccess {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///服務分流識別ID
    var fservID: Int32 = 0

    var nick: String = String()

    ///發言狀態
    var speechStatus: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ReconnectSucc {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///上一次接收到的封包時戳
    var recvTs: Int64 = 0

    ///分流識別ID     //#Jas 20211229 //! 加分流識別ID
    var servID: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

///Any_Server send_pack to Client -------------interval----------------
struct QPPProto_ServerPack {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///UTC timestamp
  var sts: Int64 = 0

  ///已讀時戳
  var rts: Int64 = 0

  ///client的自定義編號,server照著回
  var no: Int64 = 0

  ///data
  var msg: QPPProto_ServerPack.OneOf_Msg? = nil

  ///系統底層溝通-----------------------------------------
  var confirm: QPPProto_ServerPack.ReadConfirm {
    get {
      if case .confirm(let v)? = msg {return v}
      return QPPProto_ServerPack.ReadConfirm()
    }
    set {msg = .confirm(newValue)}
  }

  ///系統應用層溝通-------------------------------------------
  var error: QPPProto_Error {
    get {
      if case .error(let v)? = msg {return v}
      return QPPProto_Error()
    }
    set {msg = .error(newValue)}
  }

  ///server踢人
  var kick: QPPProto_Kick {
    get {
      if case .kick(let v)? = msg {return v}
      return QPPProto_Kick()
    }
    set {msg = .kick(newValue)}
  }

  ///回覆離開
  var quitRes: QPPProto_ServerPack.QuitResult {
    get {
      if case .quitRes(let v)? = msg {return v}
      return QPPProto_ServerPack.QuitResult()
    }
    set {msg = .quitRes(newValue)}
  }

  var againVerifyCodeRes: QPPProto_ServerPack.AgainVerifyCodeResult {
    get {
      if case .againVerifyCodeRes(let v)? = msg {return v}
      return QPPProto_ServerPack.AgainVerifyCodeResult()
    }
    set {msg = .againVerifyCodeRes(newValue)}
  }

  var verifyPreLoginRes: QPPProto_ServerPack.VerifyPreLoginResult {
    get {
      if case .verifyPreLoginRes(let v)? = msg {return v}
      return QPPProto_ServerPack.VerifyPreLoginResult()
    }
    set {msg = .verifyPreLoginRes(newValue)}
  }

  ///功能應用層------------------------------------------------
  var createAcctRes: QPPProto_ServerPack.CreateAccountResult {
    get {
      if case .createAcctRes(let v)? = msg {return v}
      return QPPProto_ServerPack.CreateAccountResult()
    }
    set {msg = .createAcctRes(newValue)}
  }

  var createUnameRes: QPPProto_ServerPack.CreateUNameResult {
    get {
      if case .createUnameRes(let v)? = msg {return v}
      return QPPProto_ServerPack.CreateUNameResult()
    }
    set {msg = .createUnameRes(newValue)}
  }

  var postCommentRes: QPPProto_ServerPack.PostCommentResult {
    get {
      if case .postCommentRes(let v)? = msg {return v}
      return QPPProto_ServerPack.PostCommentResult()
    }
    set {msg = .postCommentRes(newValue)}
  }

  var modifyCommentRes: QPPProto_ServerPack.ModifyCommentResult {
    get {
      if case .modifyCommentRes(let v)? = msg {return v}
      return QPPProto_ServerPack.ModifyCommentResult()
    }
    set {msg = .modifyCommentRes(newValue)}
  }

  var deleteCommentRes: QPPProto_ServerPack.DeleteCommentResult {
    get {
      if case .deleteCommentRes(let v)? = msg {return v}
      return QPPProto_ServerPack.DeleteCommentResult()
    }
    set {msg = .deleteCommentRes(newValue)}
  }

  var commentListRes: QPPProto_ServerPack.CommentListResult {
    get {
      if case .commentListRes(let v)? = msg {return v}
      return QPPProto_ServerPack.CommentListResult()
    }
    set {msg = .commentListRes(newValue)}
  }

  var postReportRes: QPPProto_ServerPack.PostReportResult {
    get {
      if case .postReportRes(let v)? = msg {return v}
      return QPPProto_ServerPack.PostReportResult()
    }
    set {msg = .postReportRes(newValue)}
  }

  var profilesRes: QPPProto_ServerPack.ProfilesResult {
    get {
      if case .profilesRes(let v)? = msg {return v}
      return QPPProto_ServerPack.ProfilesResult()
    }
    set {msg = .profilesRes(newValue)}
  }

  var refreshProfileRes: QPPProto_ServerPack.RefreshProfileResult {
    get {
      if case .refreshProfileRes(let v)? = msg {return v}
      return QPPProto_ServerPack.RefreshProfileResult()
    }
    set {msg = .refreshProfileRes(newValue)}
  }

  ///主動通知層------------------------------------------------
  var needUname: QPPProto_ServerPack.NeedUName {
    get {
      if case .needUname(let v)? = msg {return v}
      return QPPProto_ServerPack.NeedUName()
    }
    set {msg = .needUname(newValue)}
  }

  ///新留言
  var newComment: QPPProto_ServerPack.NewComment {
    get {
      if case .newComment(let v)? = msg {return v}
      return QPPProto_ServerPack.NewComment()
    }
    set {msg = .newComment(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///data
  enum OneOf_Msg: Equatable {
    ///系統底層溝通-----------------------------------------
    case confirm(QPPProto_ServerPack.ReadConfirm)
    ///系統應用層溝通-------------------------------------------
    case error(QPPProto_Error)
    ///server踢人
    case kick(QPPProto_Kick)
    ///回覆離開
    case quitRes(QPPProto_ServerPack.QuitResult)
    case againVerifyCodeRes(QPPProto_ServerPack.AgainVerifyCodeResult)
    case verifyPreLoginRes(QPPProto_ServerPack.VerifyPreLoginResult)
    ///功能應用層------------------------------------------------
    case createAcctRes(QPPProto_ServerPack.CreateAccountResult)
    case createUnameRes(QPPProto_ServerPack.CreateUNameResult)
    case postCommentRes(QPPProto_ServerPack.PostCommentResult)
    case modifyCommentRes(QPPProto_ServerPack.ModifyCommentResult)
    case deleteCommentRes(QPPProto_ServerPack.DeleteCommentResult)
    case commentListRes(QPPProto_ServerPack.CommentListResult)
    case postReportRes(QPPProto_ServerPack.PostReportResult)
    case profilesRes(QPPProto_ServerPack.ProfilesResult)
    case refreshProfileRes(QPPProto_ServerPack.RefreshProfileResult)
    ///主動通知層------------------------------------------------
    case needUname(QPPProto_ServerPack.NeedUName)
    ///新留言
    case newComment(QPPProto_ServerPack.NewComment)

  #if !swift(>=4.1)
    static func ==(lhs: QPPProto_ServerPack.OneOf_Msg, rhs: QPPProto_ServerPack.OneOf_Msg) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.confirm, .confirm): return {
        guard case .confirm(let l) = lhs, case .confirm(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.kick, .kick): return {
        guard case .kick(let l) = lhs, case .kick(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.quitRes, .quitRes): return {
        guard case .quitRes(let l) = lhs, case .quitRes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.againVerifyCodeRes, .againVerifyCodeRes): return {
        guard case .againVerifyCodeRes(let l) = lhs, case .againVerifyCodeRes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.verifyPreLoginRes, .verifyPreLoginRes): return {
        guard case .verifyPreLoginRes(let l) = lhs, case .verifyPreLoginRes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createAcctRes, .createAcctRes): return {
        guard case .createAcctRes(let l) = lhs, case .createAcctRes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createUnameRes, .createUnameRes): return {
        guard case .createUnameRes(let l) = lhs, case .createUnameRes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postCommentRes, .postCommentRes): return {
        guard case .postCommentRes(let l) = lhs, case .postCommentRes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.modifyCommentRes, .modifyCommentRes): return {
        guard case .modifyCommentRes(let l) = lhs, case .modifyCommentRes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteCommentRes, .deleteCommentRes): return {
        guard case .deleteCommentRes(let l) = lhs, case .deleteCommentRes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.commentListRes, .commentListRes): return {
        guard case .commentListRes(let l) = lhs, case .commentListRes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postReportRes, .postReportRes): return {
        guard case .postReportRes(let l) = lhs, case .postReportRes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.profilesRes, .profilesRes): return {
        guard case .profilesRes(let l) = lhs, case .profilesRes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.refreshProfileRes, .refreshProfileRes): return {
        guard case .refreshProfileRes(let l) = lhs, case .refreshProfileRes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.needUname, .needUname): return {
        guard case .needUname(let l) = lhs, case .needUname(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.newComment, .newComment): return {
        guard case .newComment(let l) = lhs, case .newComment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  ///inner types-------------interval----------------
  struct ReadConfirm {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct QuitResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: QPPProto_ECode = .ok

    var msg: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct AgainVerifyCodeResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: QPPProto_ECode = .ok

    var msg: String = String()

    ///下次可詢問時間
    var nextTime: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///帳號驗證結果
  struct VerifyPreLoginResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: QPPProto_ECode = .ok

    var msg: String = String()

    ///錯誤次數
    var errCount: Int32 = 0

    ///驗證成功---------------
    var needData: QPPProto_ENeedData = .noNeed

    ///needData==0,才會傳以下玩家資料
    var uname: String = String()

    var nick: String = String()

    var sysSetting: QPPProto_SysSetting {
      get {return _sysSetting ?? QPPProto_SysSetting()}
      set {_sysSetting = newValue}
    }
    /// Returns true if `sysSetting` has been explicitly set.
    var hasSysSetting: Bool {return self._sysSetting != nil}
    /// Clears the value of `sysSetting`. Subsequent reads from it will return its default value.
    mutating func clearSysSetting() {self._sysSetting = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sysSetting: QPPProto_SysSetting? = nil
  }

  struct CreateAccountResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: QPPProto_ECode = .ok

    var msg: String = String()

    ///失敗回推薦uname
    var recomdUname: String = String()

    /// 成功回角色資料 //#Jas 20220125 //補回傳角色資料
    var uname: String = String()

    var nick: String = String()

    var sysSetting: QPPProto_SysSetting {
      get {return _sysSetting ?? QPPProto_SysSetting()}
      set {_sysSetting = newValue}
    }
    /// Returns true if `sysSetting` has been explicitly set.
    var hasSysSetting: Bool {return self._sysSetting != nil}
    /// Clears the value of `sysSetting`. Subsequent reads from it will return its default value.
    mutating func clearSysSetting() {self._sysSetting = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sysSetting: QPPProto_SysSetting? = nil
  }

  struct CreateUNameResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: QPPProto_ECode = .ok

    var msg: String = String()

    ///失敗回推薦uname
    var recomdUname: String = String()

    /// 成功回角色資料 //#Jas 20220125 //補回傳角色資料
    var uname: String = String()

    var nick: String = String()

    var sysSetting: QPPProto_SysSetting {
      get {return _sysSetting ?? QPPProto_SysSetting()}
      set {_sysSetting = newValue}
    }
    /// Returns true if `sysSetting` has been explicitly set.
    var hasSysSetting: Bool {return self._sysSetting != nil}
    /// Clears the value of `sysSetting`. Subsequent reads from it will return its default value.
    mutating func clearSysSetting() {self._sysSetting = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sysSetting: QPPProto_SysSetting? = nil
  }

  struct CommentListResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: QPPProto_ECode = .ok

    var msg: String = String()

    var aryComment: [QPPProto_Comment] = []

    var nextSp: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PostCommentResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: QPPProto_ECode = .ok

    var msg: String = String()

    var comment: QPPProto_Comment {
      get {return _comment ?? QPPProto_Comment()}
      set {_comment = newValue}
    }
    /// Returns true if `comment` has been explicitly set.
    var hasComment: Bool {return self._comment != nil}
    /// Clears the value of `comment`. Subsequent reads from it will return its default value.
    mutating func clearComment() {self._comment = nil}

    ///文章的留言總數
    var commentCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _comment: QPPProto_Comment? = nil
  }

  struct ModifyCommentResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: QPPProto_ECode = .ok

    var msg: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct DeleteCommentResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: QPPProto_ECode = .ok

    var msg: String = String()

    ///文章的留言總數
    var commentCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProfilesResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: QPPProto_ECode = .ok

    var msg: String = String()

    ///頭貼url格式  //https://images.newtalk.tw/resizeQPP/50/Profile/{0}_Image1.png?v={1} //{0}:mobilKey,{1}:imgTS
    var urlFormat: String = String()

    var aryProfile: [QPPProto_Profile] = []

    ///Server Profile刷新時間,default:60s
    var refreshSec: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RefreshProfileResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: QPPProto_ECode = .ok

    var msg: String = String()

    ///頭貼url格式  //https://images.newtalk.tw/resizeQPP/50/Profile/{0}_Image1.png?v={1} //{0}:mobilKey,{1}:imgTS
    var urlFormat: String = String()

    var aryProfile: [QPPProto_Profile] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PostReportResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: QPPProto_ECode = .ok

    var msg: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///通知client還沒設uname
  struct NeedUName {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct NewComment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var aryComment: [QPPProto_Comment] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "QPP_Proto"

extension QPPProto_ECode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "EXCEPTION"),
    2: .same(proto: "ACCOUNT"),
    3: .same(proto: "TOKEN"),
    4: .same(proto: "PLAYING"),
    5: .same(proto: "TRANSFER"),
    6: .same(proto: "ARGUMENT"),
    7: .same(proto: "DB_ERROR"),
    8: .same(proto: "CACHE_ERROR"),
    9: .same(proto: "MEMORY_ERROR"),
    10: .same(proto: "NOT_LOGIN_WS"),
    11: .same(proto: "NOT_LOGIN_QPP"),
    12: .same(proto: "TOKEN_INVALID"),
  ]
}

extension QPPProto_EAccountType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GUEST"),
    1: .same(proto: "PHONE"),
    2: .same(proto: "ACCT_PW"),
    3: .same(proto: "TOKEN_LOGIN"),
  ]
}

extension QPPProto_EDeviceKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_OTHER"),
    1: .same(proto: "ANDROID"),
    2: .same(proto: "IOS"),
    3: .same(proto: "WEB"),
    4: .same(proto: "MWEB"),
  ]
}

extension QPPProto_ENeedData: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_NEED"),
    1: .same(proto: "CREATE"),
    2: .same(proto: "UNAME"),
  ]
}

extension QPPProto_EFunServType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINE"),
    1: .same(proto: "QPP"),
  ]
}

extension QPPProto_ETarget: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_TARGET"),
    1: .same(proto: "ARTICLE"),
    2: .same(proto: "COMMENT"),
  ]
}

extension QPPProto_EDelete: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_DEL"),
    1: .same(proto: "SELF"),
    2: .same(proto: "OFFICIAL"),
  ]
}

extension QPPProto_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_Error, rhs: QPPProto_Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_Kick: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Kick"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_Kick, rhs: QPPProto_Kick) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_SysSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SysSetting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trackPush"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.trackPush) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.trackPush != false {
      try visitor.visitSingularBoolField(value: self.trackPush, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_SysSetting, rhs: QPPProto_SysSetting) -> Bool {
    if lhs.trackPush != rhs.trackPush {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_Article: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Article"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ArticleId"),
    2: .same(proto: "title"),
    3: .same(proto: "authorMobilKey"),
    4: .same(proto: "url"),
    5: .same(proto: "publishTS"),
    6: .same(proto: "live"),
    7: .same(proto: "categoryNo"),
    8: .same(proto: "commentCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.articleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.authorMobilKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.publishTs) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.live) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.categoryNo) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.commentCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.articleID.isEmpty {
      try visitor.visitSingularStringField(value: self.articleID, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.authorMobilKey.isEmpty {
      try visitor.visitSingularStringField(value: self.authorMobilKey, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    if self.publishTs != 0 {
      try visitor.visitSingularInt64Field(value: self.publishTs, fieldNumber: 5)
    }
    if self.live != false {
      try visitor.visitSingularBoolField(value: self.live, fieldNumber: 6)
    }
    if self.categoryNo != 0 {
      try visitor.visitSingularInt32Field(value: self.categoryNo, fieldNumber: 7)
    }
    if self.commentCount != 0 {
      try visitor.visitSingularInt32Field(value: self.commentCount, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_Article, rhs: QPPProto_Article) -> Bool {
    if lhs.articleID != rhs.articleID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.authorMobilKey != rhs.authorMobilKey {return false}
    if lhs.url != rhs.url {return false}
    if lhs.publishTs != rhs.publishTs {return false}
    if lhs.live != rhs.live {return false}
    if lhs.categoryNo != rhs.categoryNo {return false}
    if lhs.commentCount != rhs.commentCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_Comment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Comment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "commentId"),
    2: .same(proto: "authorMobilKey"),
    3: .same(proto: "ArticleId"),
    4: .same(proto: "commentFloor"),
    5: .same(proto: "commentTS"),
    6: .same(proto: "commentContent"),
    7: .same(proto: "delete"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.commentID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.authorMobilKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.articleID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.commentFloor) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.commentTs) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.commentContent) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.delete) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commentID.isEmpty {
      try visitor.visitSingularStringField(value: self.commentID, fieldNumber: 1)
    }
    if !self.authorMobilKey.isEmpty {
      try visitor.visitSingularStringField(value: self.authorMobilKey, fieldNumber: 2)
    }
    if !self.articleID.isEmpty {
      try visitor.visitSingularStringField(value: self.articleID, fieldNumber: 3)
    }
    if self.commentFloor != 0 {
      try visitor.visitSingularInt32Field(value: self.commentFloor, fieldNumber: 4)
    }
    if self.commentTs != 0 {
      try visitor.visitSingularInt64Field(value: self.commentTs, fieldNumber: 5)
    }
    if !self.commentContent.isEmpty {
      try visitor.visitSingularStringField(value: self.commentContent, fieldNumber: 6)
    }
    if self.delete != .noDel {
      try visitor.visitSingularEnumField(value: self.delete, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_Comment, rhs: QPPProto_Comment) -> Bool {
    if lhs.commentID != rhs.commentID {return false}
    if lhs.authorMobilKey != rhs.authorMobilKey {return false}
    if lhs.articleID != rhs.articleID {return false}
    if lhs.commentFloor != rhs.commentFloor {return false}
    if lhs.commentTs != rhs.commentTs {return false}
    if lhs.commentContent != rhs.commentContent {return false}
    if lhs.delete != rhs.delete {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_Profile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Profile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mobilKey"),
    2: .same(proto: "name"),
    3: .same(proto: "imgTS"),
    4: .same(proto: "infoTS"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mobilKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.imgTs) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.infoTs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mobilKey.isEmpty {
      try visitor.visitSingularStringField(value: self.mobilKey, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.imgTs != 0 {
      try visitor.visitSingularInt64Field(value: self.imgTs, fieldNumber: 3)
    }
    if self.infoTs != 0 {
      try visitor.visitSingularInt64Field(value: self.infoTs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_Profile, rhs: QPPProto_Profile) -> Bool {
    if lhs.mobilKey != rhs.mobilKey {return false}
    if lhs.name != rhs.name {return false}
    if lhs.imgTs != rhs.imgTs {return false}
    if lhs.infoTs != rhs.infoTs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_AD: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AD"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "force"),
    3: .same(proto: "skip"),
    4: .same(proto: "totalTime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.skip) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.totalTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 2)
    }
    if self.skip != 0 {
      try visitor.visitSingularInt64Field(value: self.skip, fieldNumber: 3)
    }
    if self.totalTime != 0 {
      try visitor.visitSingularInt64Field(value: self.totalTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_AD, rhs: QPPProto_AD) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.force != rhs.force {return false}
    if lhs.skip != rhs.skip {return false}
    if lhs.totalTime != rhs.totalTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_Login: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Login"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pls"),
    2: .same(proto: "ls"),
    3: .same(proto: "lf"),
    4: .same(proto: "recnnt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: QPPProto_Login.PreLoginSys?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .pls(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .pls(v)
        }
      }()
      case 2: try {
        var v: QPPProto_Login.LoginSys?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .ls(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .ls(v)
        }
      }()
      case 3: try {
        var v: QPPProto_Login.LoginFServ?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .lf(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .lf(v)
        }
      }()
      case 4: try {
        var v: QPPProto_Login.Reconnect?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .recnnt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .recnnt(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.msg {
    case .pls?: try {
      guard case .pls(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .ls?: try {
      guard case .ls(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .lf?: try {
      guard case .lf(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .recnnt?: try {
      guard case .recnnt(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_Login, rhs: QPPProto_Login) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_Login.PreLoginSys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_Login.protoMessageName + ".PreLoginSys"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "acct"),
    2: .same(proto: "type"),
    3: .same(proto: "dkind"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.acct) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.dkind) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.acct.isEmpty {
      try visitor.visitSingularStringField(value: self.acct, fieldNumber: 1)
    }
    if self.type != .guest {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.dkind != .deviceOther {
      try visitor.visitSingularEnumField(value: self.dkind, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_Login.PreLoginSys, rhs: QPPProto_Login.PreLoginSys) -> Bool {
    if lhs.acct != rhs.acct {return false}
    if lhs.type != rhs.type {return false}
    if lhs.dkind != rhs.dkind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_Login.LoginSys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_Login.protoMessageName + ".LoginSys"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "acct"),
    2: .same(proto: "pw"),
    3: .same(proto: "type"),
    4: .same(proto: "dkind"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.acct) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pw) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.dkind) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.acct.isEmpty {
      try visitor.visitSingularStringField(value: self.acct, fieldNumber: 1)
    }
    if !self.pw.isEmpty {
      try visitor.visitSingularStringField(value: self.pw, fieldNumber: 2)
    }
    if self.type != .guest {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if self.dkind != .deviceOther {
      try visitor.visitSingularEnumField(value: self.dkind, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_Login.LoginSys, rhs: QPPProto_Login.LoginSys) -> Bool {
    if lhs.acct != rhs.acct {return false}
    if lhs.pw != rhs.pw {return false}
    if lhs.type != rhs.type {return false}
    if lhs.dkind != rhs.dkind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_Login.LoginFServ: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_Login.protoMessageName + ".LoginFServ"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "dkind"),
    3: .same(proto: "sservID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.dkind) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.sservID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if self.dkind != .deviceOther {
      try visitor.visitSingularEnumField(value: self.dkind, fieldNumber: 2)
    }
    if self.sservID != 0 {
      try visitor.visitSingularInt32Field(value: self.sservID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_Login.LoginFServ, rhs: QPPProto_Login.LoginFServ) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.dkind != rhs.dkind {return false}
    if lhs.sservID != rhs.sservID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_Login.Reconnect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_Login.protoMessageName + ".Reconnect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "recvTS"),
    3: .same(proto: "dkind"),
    4: .same(proto: "sservID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.recvTs) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.dkind) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.sservID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if self.recvTs != 0 {
      try visitor.visitSingularInt64Field(value: self.recvTs, fieldNumber: 2)
    }
    if self.dkind != .deviceOther {
      try visitor.visitSingularEnumField(value: self.dkind, fieldNumber: 3)
    }
    if self.sservID != 0 {
      try visitor.visitSingularInt32Field(value: self.sservID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_Login.Reconnect, rhs: QPPProto_Login.Reconnect) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.recvTs != rhs.recvTs {return false}
    if lhs.dkind != rhs.dkind {return false}
    if lhs.sservID != rhs.sservID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ClientPack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientPack"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sts"),
    2: .same(proto: "rts"),
    3: .same(proto: "no"),
    4: .same(proto: "confirmRes"),
    5: .same(proto: "ChangeSys"),
    6: .same(proto: "quit"),
    7: .same(proto: "againVerifyCode"),
    8: .same(proto: "verifyPreLogin"),
    9: .same(proto: "createAcct"),
    10: .same(proto: "createUName"),
    11: .same(proto: "sysSetting"),
    12: .same(proto: "postComment"),
    13: .same(proto: "modifyComment"),
    14: .same(proto: "deleteComment"),
    15: .same(proto: "commentList"),
    16: .same(proto: "postReport"),
    17: .same(proto: "profiles"),
    18: .same(proto: "refreshProfile"),
    19: .same(proto: "liveInit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.sts) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.rts) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.no) }()
      case 4: try {
        var v: QPPProto_ClientPack.ReadConfirmResult?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .confirmRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .confirmRes(v)
        }
      }()
      case 5: try {
        var v: QPPProto_ClientPack.ChangeSystem?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .changeSys(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .changeSys(v)
        }
      }()
      case 6: try {
        var v: QPPProto_ClientPack.Quit?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .quit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .quit(v)
        }
      }()
      case 7: try {
        var v: QPPProto_ClientPack.AgainVerifyCode?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .againVerifyCode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .againVerifyCode(v)
        }
      }()
      case 8: try {
        var v: QPPProto_ClientPack.VerifyPreLogin?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .verifyPreLogin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .verifyPreLogin(v)
        }
      }()
      case 9: try {
        var v: QPPProto_ClientPack.CreateAccount?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .createAcct(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .createAcct(v)
        }
      }()
      case 10: try {
        var v: QPPProto_ClientPack.CreateUName?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .createUname(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .createUname(v)
        }
      }()
      case 11: try {
        var v: QPPProto_SysSetting?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .sysSetting(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .sysSetting(v)
        }
      }()
      case 12: try {
        var v: QPPProto_ClientPack.PostComment?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .postComment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .postComment(v)
        }
      }()
      case 13: try {
        var v: QPPProto_ClientPack.ModifyComment?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .modifyComment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .modifyComment(v)
        }
      }()
      case 14: try {
        var v: QPPProto_ClientPack.DeleteComment?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .deleteComment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .deleteComment(v)
        }
      }()
      case 15: try {
        var v: QPPProto_ClientPack.CommentList?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .commentList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .commentList(v)
        }
      }()
      case 16: try {
        var v: QPPProto_ClientPack.PostReport?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .postReport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .postReport(v)
        }
      }()
      case 17: try {
        var v: QPPProto_ClientPack.Profiles?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .profiles(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .profiles(v)
        }
      }()
      case 18: try {
        var v: QPPProto_ClientPack.RefreshProfile?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .refreshProfile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .refreshProfile(v)
        }
      }()
      case 19: try {
        var v: QPPProto_ClientPack.LiveInit?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .liveInit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .liveInit(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sts != 0 {
      try visitor.visitSingularInt64Field(value: self.sts, fieldNumber: 1)
    }
    if self.rts != 0 {
      try visitor.visitSingularInt64Field(value: self.rts, fieldNumber: 2)
    }
    if self.no != 0 {
      try visitor.visitSingularInt64Field(value: self.no, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.msg {
    case .confirmRes?: try {
      guard case .confirmRes(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .changeSys?: try {
      guard case .changeSys(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .quit?: try {
      guard case .quit(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .againVerifyCode?: try {
      guard case .againVerifyCode(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .verifyPreLogin?: try {
      guard case .verifyPreLogin(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .createAcct?: try {
      guard case .createAcct(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .createUname?: try {
      guard case .createUname(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .sysSetting?: try {
      guard case .sysSetting(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .postComment?: try {
      guard case .postComment(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .modifyComment?: try {
      guard case .modifyComment(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .deleteComment?: try {
      guard case .deleteComment(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .commentList?: try {
      guard case .commentList(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .postReport?: try {
      guard case .postReport(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .profiles?: try {
      guard case .profiles(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .refreshProfile?: try {
      guard case .refreshProfile(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .liveInit?: try {
      guard case .liveInit(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ClientPack, rhs: QPPProto_ClientPack) -> Bool {
    if lhs.sts != rhs.sts {return false}
    if lhs.rts != rhs.rts {return false}
    if lhs.no != rhs.no {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ClientPack.ReadConfirmResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ClientPack.protoMessageName + ".ReadConfirmResult"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ClientPack.ReadConfirmResult, rhs: QPPProto_ClientPack.ReadConfirmResult) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ClientPack.ChangeSystem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ClientPack.protoMessageName + ".ChangeSystem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sservID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sservID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sservID != 0 {
      try visitor.visitSingularInt32Field(value: self.sservID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ClientPack.ChangeSystem, rhs: QPPProto_ClientPack.ChangeSystem) -> Bool {
    if lhs.sservID != rhs.sservID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ClientPack.Quit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ClientPack.protoMessageName + ".Quit"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ClientPack.Quit, rhs: QPPProto_ClientPack.Quit) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ClientPack.AgainVerifyCode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ClientPack.protoMessageName + ".AgainVerifyCode"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ClientPack.AgainVerifyCode, rhs: QPPProto_ClientPack.AgainVerifyCode) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ClientPack.VerifyPreLogin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ClientPack.protoMessageName + ".VerifyPreLogin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ClientPack.VerifyPreLogin, rhs: QPPProto_ClientPack.VerifyPreLogin) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ClientPack.CreateAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ClientPack.protoMessageName + ".CreateAccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uname) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uname.isEmpty {
      try visitor.visitSingularStringField(value: self.uname, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ClientPack.CreateAccount, rhs: QPPProto_ClientPack.CreateAccount) -> Bool {
    if lhs.uname != rhs.uname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ClientPack.CreateUName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ClientPack.protoMessageName + ".CreateUName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uname) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uname.isEmpty {
      try visitor.visitSingularStringField(value: self.uname, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ClientPack.CreateUName, rhs: QPPProto_ClientPack.CreateUName) -> Bool {
    if lhs.uname != rhs.uname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ClientPack.CommentList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ClientPack.protoMessageName + ".CommentList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ArticleId"),
    2: .same(proto: "nextSP"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.articleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextSp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.articleID.isEmpty {
      try visitor.visitSingularStringField(value: self.articleID, fieldNumber: 1)
    }
    if !self.nextSp.isEmpty {
      try visitor.visitSingularStringField(value: self.nextSp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ClientPack.CommentList, rhs: QPPProto_ClientPack.CommentList) -> Bool {
    if lhs.articleID != rhs.articleID {return false}
    if lhs.nextSp != rhs.nextSp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ClientPack.PostComment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ClientPack.protoMessageName + ".PostComment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ArticleId"),
    2: .same(proto: "content"),
    3: .same(proto: "imgCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.articleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.imgCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.articleID.isEmpty {
      try visitor.visitSingularStringField(value: self.articleID, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    if self.imgCount != 0 {
      try visitor.visitSingularInt32Field(value: self.imgCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ClientPack.PostComment, rhs: QPPProto_ClientPack.PostComment) -> Bool {
    if lhs.articleID != rhs.articleID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.imgCount != rhs.imgCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ClientPack.ModifyComment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ClientPack.protoMessageName + ".ModifyComment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "commentId"),
    2: .same(proto: "content"),
    3: .same(proto: "imgCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.commentID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.imgCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commentID.isEmpty {
      try visitor.visitSingularStringField(value: self.commentID, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    if self.imgCount != 0 {
      try visitor.visitSingularInt32Field(value: self.imgCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ClientPack.ModifyComment, rhs: QPPProto_ClientPack.ModifyComment) -> Bool {
    if lhs.commentID != rhs.commentID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.imgCount != rhs.imgCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ClientPack.DeleteComment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ClientPack.protoMessageName + ".DeleteComment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "commentId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.commentID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commentID.isEmpty {
      try visitor.visitSingularStringField(value: self.commentID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ClientPack.DeleteComment, rhs: QPPProto_ClientPack.DeleteComment) -> Bool {
    if lhs.commentID != rhs.commentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ClientPack.Profiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ClientPack.protoMessageName + ".Profiles"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "aryMKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.aryMkey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.aryMkey.isEmpty {
      try visitor.visitRepeatedStringField(value: self.aryMkey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ClientPack.Profiles, rhs: QPPProto_ClientPack.Profiles) -> Bool {
    if lhs.aryMkey != rhs.aryMkey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ClientPack.RefreshProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ClientPack.protoMessageName + ".RefreshProfile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastTS"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.lastTs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lastTs != 0 {
      try visitor.visitSingularInt64Field(value: self.lastTs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ClientPack.RefreshProfile, rhs: QPPProto_ClientPack.RefreshProfile) -> Bool {
    if lhs.lastTs != rhs.lastTs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ClientPack.PostReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ClientPack.protoMessageName + ".PostReport"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "target"),
    2: .same(proto: "id"),
    3: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.target) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.target != .noTarget {
      try visitor.visitSingularEnumField(value: self.target, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ClientPack.PostReport, rhs: QPPProto_ClientPack.PostReport) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.id != rhs.id {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ClientPack.LiveInit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ClientPack.protoMessageName + ".LiveInit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startTime"),
    2: .same(proto: "watchs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.startTime) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.watchs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startTime != 0 {
      try visitor.visitSingularInt64Field(value: self.startTime, fieldNumber: 1)
    }
    if self.watchs != 0 {
      try visitor.visitSingularInt32Field(value: self.watchs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ClientPack.LiveInit, rhs: QPPProto_ClientPack.LiveInit) -> Bool {
    if lhs.startTime != rhs.startTime {return false}
    if lhs.watchs != rhs.watchs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_LoginResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoginResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "plssucc"),
    3: .same(proto: "ssucc"),
    4: .same(proto: "fsucc"),
    5: .same(proto: "recnntSucc"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: QPPProto_Error?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .error(v)
        }
      }()
      case 2: try {
        var v: QPPProto_LoginResult.PLSSuccess?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .plssucc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .plssucc(v)
        }
      }()
      case 3: try {
        var v: QPPProto_LoginResult.SSuccess?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .ssucc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .ssucc(v)
        }
      }()
      case 4: try {
        var v: QPPProto_LoginResult.FSuccess?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .fsucc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .fsucc(v)
        }
      }()
      case 5: try {
        var v: QPPProto_LoginResult.ReconnectSucc?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .recnntSucc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .recnntSucc(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.msg {
    case .error?: try {
      guard case .error(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .plssucc?: try {
      guard case .plssucc(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .ssucc?: try {
      guard case .ssucc(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .fsucc?: try {
      guard case .fsucc(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .recnntSucc?: try {
      guard case .recnntSucc(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_LoginResult, rhs: QPPProto_LoginResult) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_LoginResult.PLSSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_LoginResult.protoMessageName + ".PLSSuccess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sservID"),
    2: .same(proto: "token"),
    3: .same(proto: "refreshToken"),
    4: .same(proto: "aliveSec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sservID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.refreshToken) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.aliveSec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sservID != 0 {
      try visitor.visitSingularInt32Field(value: self.sservID, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    if !self.refreshToken.isEmpty {
      try visitor.visitSingularStringField(value: self.refreshToken, fieldNumber: 3)
    }
    if self.aliveSec != 0 {
      try visitor.visitSingularInt32Field(value: self.aliveSec, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_LoginResult.PLSSuccess, rhs: QPPProto_LoginResult.PLSSuccess) -> Bool {
    if lhs.sservID != rhs.sservID {return false}
    if lhs.token != rhs.token {return false}
    if lhs.refreshToken != rhs.refreshToken {return false}
    if lhs.aliveSec != rhs.aliveSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_LoginResult.SSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_LoginResult.protoMessageName + ".SSuccess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sservID"),
    2: .same(proto: "token"),
    3: .same(proto: "refreshToken"),
    4: .same(proto: "aliveSec"),
    5: .same(proto: "nick"),
    6: .same(proto: "sysSetting"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sservID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.refreshToken) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.aliveSec) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.nick) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._sysSetting) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sservID != 0 {
      try visitor.visitSingularInt32Field(value: self.sservID, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    if !self.refreshToken.isEmpty {
      try visitor.visitSingularStringField(value: self.refreshToken, fieldNumber: 3)
    }
    if self.aliveSec != 0 {
      try visitor.visitSingularInt32Field(value: self.aliveSec, fieldNumber: 4)
    }
    if !self.nick.isEmpty {
      try visitor.visitSingularStringField(value: self.nick, fieldNumber: 5)
    }
    if let v = self._sysSetting {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_LoginResult.SSuccess, rhs: QPPProto_LoginResult.SSuccess) -> Bool {
    if lhs.sservID != rhs.sservID {return false}
    if lhs.token != rhs.token {return false}
    if lhs.refreshToken != rhs.refreshToken {return false}
    if lhs.aliveSec != rhs.aliveSec {return false}
    if lhs.nick != rhs.nick {return false}
    if lhs._sysSetting != rhs._sysSetting {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_LoginResult.FSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_LoginResult.protoMessageName + ".FSuccess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fservID"),
    2: .same(proto: "nick"),
    3: .same(proto: "speechStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.fservID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nick) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.speechStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fservID != 0 {
      try visitor.visitSingularInt32Field(value: self.fservID, fieldNumber: 1)
    }
    if !self.nick.isEmpty {
      try visitor.visitSingularStringField(value: self.nick, fieldNumber: 2)
    }
    if self.speechStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.speechStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_LoginResult.FSuccess, rhs: QPPProto_LoginResult.FSuccess) -> Bool {
    if lhs.fservID != rhs.fservID {return false}
    if lhs.nick != rhs.nick {return false}
    if lhs.speechStatus != rhs.speechStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_LoginResult.ReconnectSucc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_LoginResult.protoMessageName + ".ReconnectSucc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recvTS"),
    2: .same(proto: "servID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.recvTs) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.servID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.recvTs != 0 {
      try visitor.visitSingularInt64Field(value: self.recvTs, fieldNumber: 1)
    }
    if self.servID != 0 {
      try visitor.visitSingularInt32Field(value: self.servID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_LoginResult.ReconnectSucc, rhs: QPPProto_LoginResult.ReconnectSucc) -> Bool {
    if lhs.recvTs != rhs.recvTs {return false}
    if lhs.servID != rhs.servID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ServerPack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerPack"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sts"),
    2: .same(proto: "rts"),
    3: .same(proto: "no"),
    4: .same(proto: "confirm"),
    5: .same(proto: "error"),
    6: .same(proto: "kick"),
    7: .same(proto: "quitRes"),
    8: .same(proto: "againVerifyCodeRes"),
    9: .same(proto: "verifyPreLoginRes"),
    10: .same(proto: "createAcctRes"),
    11: .same(proto: "createUNameRes"),
    12: .same(proto: "postCommentRes"),
    13: .same(proto: "modifyCommentRes"),
    14: .same(proto: "deleteCommentRes"),
    15: .same(proto: "commentListRes"),
    16: .same(proto: "PostReportRes"),
    17: .same(proto: "profilesRes"),
    18: .same(proto: "RefreshProfileRes"),
    19: .same(proto: "needUName"),
    20: .same(proto: "newComment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.sts) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.rts) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.no) }()
      case 4: try {
        var v: QPPProto_ServerPack.ReadConfirm?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .confirm(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .confirm(v)
        }
      }()
      case 5: try {
        var v: QPPProto_Error?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .error(v)
        }
      }()
      case 6: try {
        var v: QPPProto_Kick?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .kick(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .kick(v)
        }
      }()
      case 7: try {
        var v: QPPProto_ServerPack.QuitResult?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .quitRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .quitRes(v)
        }
      }()
      case 8: try {
        var v: QPPProto_ServerPack.AgainVerifyCodeResult?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .againVerifyCodeRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .againVerifyCodeRes(v)
        }
      }()
      case 9: try {
        var v: QPPProto_ServerPack.VerifyPreLoginResult?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .verifyPreLoginRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .verifyPreLoginRes(v)
        }
      }()
      case 10: try {
        var v: QPPProto_ServerPack.CreateAccountResult?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .createAcctRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .createAcctRes(v)
        }
      }()
      case 11: try {
        var v: QPPProto_ServerPack.CreateUNameResult?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .createUnameRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .createUnameRes(v)
        }
      }()
      case 12: try {
        var v: QPPProto_ServerPack.PostCommentResult?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .postCommentRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .postCommentRes(v)
        }
      }()
      case 13: try {
        var v: QPPProto_ServerPack.ModifyCommentResult?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .modifyCommentRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .modifyCommentRes(v)
        }
      }()
      case 14: try {
        var v: QPPProto_ServerPack.DeleteCommentResult?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .deleteCommentRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .deleteCommentRes(v)
        }
      }()
      case 15: try {
        var v: QPPProto_ServerPack.CommentListResult?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .commentListRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .commentListRes(v)
        }
      }()
      case 16: try {
        var v: QPPProto_ServerPack.PostReportResult?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .postReportRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .postReportRes(v)
        }
      }()
      case 17: try {
        var v: QPPProto_ServerPack.ProfilesResult?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .profilesRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .profilesRes(v)
        }
      }()
      case 18: try {
        var v: QPPProto_ServerPack.RefreshProfileResult?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .refreshProfileRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .refreshProfileRes(v)
        }
      }()
      case 19: try {
        var v: QPPProto_ServerPack.NeedUName?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .needUname(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .needUname(v)
        }
      }()
      case 20: try {
        var v: QPPProto_ServerPack.NewComment?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .newComment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .newComment(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sts != 0 {
      try visitor.visitSingularInt64Field(value: self.sts, fieldNumber: 1)
    }
    if self.rts != 0 {
      try visitor.visitSingularInt64Field(value: self.rts, fieldNumber: 2)
    }
    if self.no != 0 {
      try visitor.visitSingularInt64Field(value: self.no, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.msg {
    case .confirm?: try {
      guard case .confirm(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .error?: try {
      guard case .error(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .kick?: try {
      guard case .kick(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .quitRes?: try {
      guard case .quitRes(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .againVerifyCodeRes?: try {
      guard case .againVerifyCodeRes(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .verifyPreLoginRes?: try {
      guard case .verifyPreLoginRes(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .createAcctRes?: try {
      guard case .createAcctRes(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .createUnameRes?: try {
      guard case .createUnameRes(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .postCommentRes?: try {
      guard case .postCommentRes(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .modifyCommentRes?: try {
      guard case .modifyCommentRes(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .deleteCommentRes?: try {
      guard case .deleteCommentRes(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .commentListRes?: try {
      guard case .commentListRes(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .postReportRes?: try {
      guard case .postReportRes(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .profilesRes?: try {
      guard case .profilesRes(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .refreshProfileRes?: try {
      guard case .refreshProfileRes(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .needUname?: try {
      guard case .needUname(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .newComment?: try {
      guard case .newComment(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ServerPack, rhs: QPPProto_ServerPack) -> Bool {
    if lhs.sts != rhs.sts {return false}
    if lhs.rts != rhs.rts {return false}
    if lhs.no != rhs.no {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ServerPack.ReadConfirm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ServerPack.protoMessageName + ".ReadConfirm"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ServerPack.ReadConfirm, rhs: QPPProto_ServerPack.ReadConfirm) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ServerPack.QuitResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ServerPack.protoMessageName + ".QuitResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ServerPack.QuitResult, rhs: QPPProto_ServerPack.QuitResult) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ServerPack.AgainVerifyCodeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ServerPack.protoMessageName + ".AgainVerifyCodeResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "msg"),
    3: .same(proto: "nextTime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.nextTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    if self.nextTime != 0 {
      try visitor.visitSingularInt64Field(value: self.nextTime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ServerPack.AgainVerifyCodeResult, rhs: QPPProto_ServerPack.AgainVerifyCodeResult) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.nextTime != rhs.nextTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ServerPack.VerifyPreLoginResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ServerPack.protoMessageName + ".VerifyPreLoginResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "msg"),
    3: .same(proto: "errCount"),
    4: .same(proto: "needData"),
    5: .same(proto: "uname"),
    6: .same(proto: "nick"),
    7: .same(proto: "sysSetting"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.errCount) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.needData) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.uname) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.nick) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._sysSetting) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    if self.errCount != 0 {
      try visitor.visitSingularInt32Field(value: self.errCount, fieldNumber: 3)
    }
    if self.needData != .noNeed {
      try visitor.visitSingularEnumField(value: self.needData, fieldNumber: 4)
    }
    if !self.uname.isEmpty {
      try visitor.visitSingularStringField(value: self.uname, fieldNumber: 5)
    }
    if !self.nick.isEmpty {
      try visitor.visitSingularStringField(value: self.nick, fieldNumber: 6)
    }
    if let v = self._sysSetting {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ServerPack.VerifyPreLoginResult, rhs: QPPProto_ServerPack.VerifyPreLoginResult) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.errCount != rhs.errCount {return false}
    if lhs.needData != rhs.needData {return false}
    if lhs.uname != rhs.uname {return false}
    if lhs.nick != rhs.nick {return false}
    if lhs._sysSetting != rhs._sysSetting {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ServerPack.CreateAccountResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ServerPack.protoMessageName + ".CreateAccountResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "msg"),
    3: .same(proto: "recomdUName"),
    4: .same(proto: "uname"),
    5: .same(proto: "nick"),
    6: .same(proto: "sysSetting"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.recomdUname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uname) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.nick) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._sysSetting) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    if !self.recomdUname.isEmpty {
      try visitor.visitSingularStringField(value: self.recomdUname, fieldNumber: 3)
    }
    if !self.uname.isEmpty {
      try visitor.visitSingularStringField(value: self.uname, fieldNumber: 4)
    }
    if !self.nick.isEmpty {
      try visitor.visitSingularStringField(value: self.nick, fieldNumber: 5)
    }
    if let v = self._sysSetting {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ServerPack.CreateAccountResult, rhs: QPPProto_ServerPack.CreateAccountResult) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.recomdUname != rhs.recomdUname {return false}
    if lhs.uname != rhs.uname {return false}
    if lhs.nick != rhs.nick {return false}
    if lhs._sysSetting != rhs._sysSetting {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ServerPack.CreateUNameResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ServerPack.protoMessageName + ".CreateUNameResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "msg"),
    3: .same(proto: "recomdUName"),
    4: .same(proto: "uname"),
    5: .same(proto: "nick"),
    6: .same(proto: "sysSetting"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.recomdUname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uname) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.nick) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._sysSetting) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    if !self.recomdUname.isEmpty {
      try visitor.visitSingularStringField(value: self.recomdUname, fieldNumber: 3)
    }
    if !self.uname.isEmpty {
      try visitor.visitSingularStringField(value: self.uname, fieldNumber: 4)
    }
    if !self.nick.isEmpty {
      try visitor.visitSingularStringField(value: self.nick, fieldNumber: 5)
    }
    if let v = self._sysSetting {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ServerPack.CreateUNameResult, rhs: QPPProto_ServerPack.CreateUNameResult) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.recomdUname != rhs.recomdUname {return false}
    if lhs.uname != rhs.uname {return false}
    if lhs.nick != rhs.nick {return false}
    if lhs._sysSetting != rhs._sysSetting {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ServerPack.CommentListResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ServerPack.protoMessageName + ".CommentListResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "msg"),
    3: .same(proto: "aryComment"),
    4: .same(proto: "nextSP"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.aryComment) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nextSp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    if !self.aryComment.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aryComment, fieldNumber: 3)
    }
    if !self.nextSp.isEmpty {
      try visitor.visitSingularStringField(value: self.nextSp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ServerPack.CommentListResult, rhs: QPPProto_ServerPack.CommentListResult) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.aryComment != rhs.aryComment {return false}
    if lhs.nextSp != rhs.nextSp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ServerPack.PostCommentResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ServerPack.protoMessageName + ".PostCommentResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "msg"),
    3: .same(proto: "comment"),
    4: .same(proto: "commentCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._comment) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.commentCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    if let v = self._comment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.commentCount != 0 {
      try visitor.visitSingularInt32Field(value: self.commentCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ServerPack.PostCommentResult, rhs: QPPProto_ServerPack.PostCommentResult) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._comment != rhs._comment {return false}
    if lhs.commentCount != rhs.commentCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ServerPack.ModifyCommentResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ServerPack.protoMessageName + ".ModifyCommentResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ServerPack.ModifyCommentResult, rhs: QPPProto_ServerPack.ModifyCommentResult) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ServerPack.DeleteCommentResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ServerPack.protoMessageName + ".DeleteCommentResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "msg"),
    3: .same(proto: "commentCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.commentCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    if self.commentCount != 0 {
      try visitor.visitSingularInt32Field(value: self.commentCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ServerPack.DeleteCommentResult, rhs: QPPProto_ServerPack.DeleteCommentResult) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.commentCount != rhs.commentCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ServerPack.ProfilesResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ServerPack.protoMessageName + ".ProfilesResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "msg"),
    3: .same(proto: "urlFormat"),
    4: .same(proto: "aryProfile"),
    5: .same(proto: "refreshSec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.urlFormat) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.aryProfile) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.refreshSec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    if !self.urlFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.urlFormat, fieldNumber: 3)
    }
    if !self.aryProfile.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aryProfile, fieldNumber: 4)
    }
    if self.refreshSec != 0 {
      try visitor.visitSingularInt32Field(value: self.refreshSec, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ServerPack.ProfilesResult, rhs: QPPProto_ServerPack.ProfilesResult) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.urlFormat != rhs.urlFormat {return false}
    if lhs.aryProfile != rhs.aryProfile {return false}
    if lhs.refreshSec != rhs.refreshSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ServerPack.RefreshProfileResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ServerPack.protoMessageName + ".RefreshProfileResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "msg"),
    3: .same(proto: "urlFormat"),
    4: .same(proto: "aryProfile"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.urlFormat) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.aryProfile) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    if !self.urlFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.urlFormat, fieldNumber: 3)
    }
    if !self.aryProfile.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aryProfile, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ServerPack.RefreshProfileResult, rhs: QPPProto_ServerPack.RefreshProfileResult) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.urlFormat != rhs.urlFormat {return false}
    if lhs.aryProfile != rhs.aryProfile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ServerPack.PostReportResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ServerPack.protoMessageName + ".PostReportResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ServerPack.PostReportResult, rhs: QPPProto_ServerPack.PostReportResult) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ServerPack.NeedUName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ServerPack.protoMessageName + ".NeedUName"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ServerPack.NeedUName, rhs: QPPProto_ServerPack.NeedUName) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QPPProto_ServerPack.NewComment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = QPPProto_ServerPack.protoMessageName + ".NewComment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "aryComment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.aryComment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.aryComment.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aryComment, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QPPProto_ServerPack.NewComment, rhs: QPPProto_ServerPack.NewComment) -> Bool {
    if lhs.aryComment != rhs.aryComment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
